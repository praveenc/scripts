<#
.Synopsis
   Reads SVN XML Log and Transforms to document readable by SOLR
.DESCRIPTION
   Reads XML generated by svn log and then transforms to SOLR readable xml format.
   SOLR XML fields used in this program are as defined in schema.xml of SOLR on 10.10.24.142:8983/solr
.EXAMPLE
   Transform-XML2SOLRXML.ps1 -XMLFileToRead c:\archive_trunk_svnlog.xml -SVNBranchName "archive/trunk"
.EXAMPLE
   Another example of how to use this cmdlet
.NOTES
    Author: Praveen Chamarthi
    Date: 06/19/2014
#>
[CmdletBinding()]
Param
    (
        # XML File To Read
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [ValidateScript({Test-Path $_})]
        [String] $XMLFileToRead,

        # Param2 help description
        [Parameter(Mandatory=$false,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        [String] $SVNBranchName="myserver"
    )

$fileToRead = $XMLFileToRead
$svn_url = "svn+ssh://svn.myserver.com"
$branch_name = "$svn_url/$SVNBranchName"
$filename = Split-Path $fileToRead -Leaf
$filepath = Split-Path $fileToRead -Parent


Write-Output "SVN Branch Name Set to: $branch_name"
Write-Output "Loading xml contents into xml_data ..."
[xml]$xml_data = Get-Content $fileToRead

Write-Output "Querying Nodes using XPath ..."
#Use XPath to capture all Nodes with name logentry in SVN Log
$logentry = Select-Xml "//logentry" $xml_data

if($logentry.Count -eq 0){
    Write-Output "$fileToRead has no Nodes with name logentry"
    exit 0
}

Write-Output "Checking if Transformed_FILENAME.xml exist ..."
#Delete if output file already exists
if(Test-Path "$filepath\Transformed_$filename"){
    Write-Output "Deleting $filepath\Transformed_$filename"
    Remove-Item -Path "$filepath\Transformed_$filename" -Force | Out-Null
}

Write-Output "Initiating XML Transform ..."
#Create a Here String variable for writing the final XML"
$transformed_node=@"
<?xml version="1.0" encoding="UTF-8"?>
<add>

"@
$transformed_node | Out-File "$filepath\Transformed_$filename" -Append utf8
Write-Output "transforming $($logentry.Count) Nodes to SOLR readable format ..."
foreach($log in $logentry){
    
    $revision = $log.Node.revision
    $author = $log.Node.author
    $last_modified = $log.Node.date
    $msg = $log.Node.msg
$transformed_node=@"
    <doc>
        <field name="id">$revision</field>
        <field name="branchname_s">$branch_name</field>
        <field name="author_s">$author</field>
        <field name="last_modified_dt">$last_modified</field>
        <field name="comments_txt"><![CDATA[$msg]]></field>

"@
    $paths = $log.Node.paths.path
    $appended_string = "`r`n"
    foreach($path in $paths){
        $appended_string += "Kind: $($path.kind) - Action: $($path.action) - Path: $($path.'#text')`r`n"
   }

$transformed_node+=@"
        <field name="content_txt"><![CDATA[$appended_string]]></field>
   </doc>
"@
 
$transformed_node | Out-File "$filepath\Transformed_$filename" -Append utf8
$transformed_node=@"
"@
}
$transformed_node=@"
</add>
"@

#$transformed_node = $transformed_node | % {if($_ -match "\&"){$_ -replace "\&","&amp;"}else{$_}}

$transformed_node | Out-File "$filepath\Transformed_$filename" -Append utf8

Write-Output "Transformation Complete ..."
Write-Output "File written to: $filepath\Transformed_$filename"
